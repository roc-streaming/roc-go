package roc

/*
#include "roc/config.h"
*/
import "C"
import "time"

// Network slot.
//
// A peer (sender or receiver) may have multiple slots, which may be independently
// bound or connected. You can use multiple slots on sender to connect it to multiple
// receiver addresses, and you can use multiple slots on receiver to bind it to
// multiple receiver address.
//
// Slots are numbered from zero and are created implicitly. Just specify slot index
// when binding or connecting endpoint, and slot will be automatically created if it
// was not created yet.
//
// In simple cases, just use SlotDefault.
//
// Each slot has its own set of interfaces, dedicated to different kinds of endpoints.
// See Interface for details.
type Slot int

const (
	// Alias for the slot with index zero.
	SlotDefault Slot = 0
)

// Context configuration.
// You can zero-initialize this struct to get a default config.
// See also Context.
type ContextConfig struct {
	// Maximum size in bytes of a network packet.
	// Defines the amount of bytes allocated per network packet.
	// Sender and receiver won't handle packets larger than this.
	// If zero, default value is used.
	MaxPacketSize uint32

	// Maximum size in bytes of an audio frame.
	// Defines the amount of bytes allocated per intermediate internal frame in the
	// pipeline. Does not limit the size of the frames provided by user.
	// If zero, default value is used.
	MaxFrameSize uint32
}

// Sender configuration.
// You can zero-initialize this struct to get a default config.
// See also Sender.
type SenderConfig struct {
	// The rate of the samples in the frames passed to sender.
	// Number of samples per channel per second.
	// If FrameSampleRate and PacketSampleRate are different,
	// resampler should be enabled.
	// Should be set.
	FrameSampleRate uint32

	// The channel set in the frames passed to sender.
	// Should be set.
	FrameChannels ChannelSet

	// The sample encoding in the frames passed to sender.
	// Should be set.
	FrameEncoding FrameEncoding

	// The rate of the samples in the packets generated by sender.
	// Number of samples per channel per second.
	// If zero, default value is used.
	PacketSampleRate uint32

	// The channel set in the packets generated by sender.
	// If zero, default value is used.
	PacketChannels ChannelSet

	// The sample encoding in the packets generated by sender.
	// If zero, default value is used.
	PacketEncoding PacketEncoding

	// The length of the packets produced by sender, in nanoseconds.
	// Number of nanoseconds encoded per packet.
	// The samples written to the sender are buffered until the full packet is
	// accumulated or the sender is flushed or closed. Larger number reduces
	// packet overhead but also increases latency.
	// If zero, default value is used. Should not be negative, otherwise an error is returned.
	PacketLength time.Duration

	// Enable packet interleaving.
	// If true, the sender shuffles packets before sending them. This
	// may increase robustness but also increases latency.
	PacketInterleaving bool

	// Clock source to use.
	// Defines whether write operation will be blocking or non-blocking.
	// If zero, default value is used.
	ClockSource ClockSource

	// Resampler backend to use.
	ResamplerBackend ResamplerBackend

	// Resampler profile to use.
	// If non-zero, the sender employs resampler if the frame sample rate differs
	// from the packet sample rate.
	ResamplerProfile ResamplerProfile

	// FEC encoding to use.
	// If non-zero, the sender employs a FEC codec to generate redundant packets
	// which may be used on receiver to restore lost packets. This requires both
	// sender and receiver to use two separate source and repair ports.
	FecEncoding FecEncoding

	// Number of source packets per FEC block.
	// Used if some FEC code is selected.
	// Larger number increases robustness but also increases latency.
	// If zero, default value is used.
	FecBlockSourcePackets uint32

	// Number of repair packets per FEC block.
	// Used if some FEC code is selected.
	// Larger number increases robustness but also increases traffic.
	// If zero, default value is used.
	FecBlockRepairPackets uint32
}

// Receiver configuration.
// You can zero-initialize this struct to get a default config.
// See also Receiver.
type ReceiverConfig struct {
	// The rate of the samples in the frames returned to the user.
	// Number of samples per channel per second.
	// Should be set.
	FrameSampleRate uint32

	// The channel set in the frames returned to the user.
	// Should be set.
	FrameChannels ChannelSet

	// The sample encoding in the frames returned to the user.
	// Should be set.
	FrameEncoding FrameEncoding

	// Clock source to use.
	// Defines whether read operation will be blocking or non-blocking.
	// If zero, default value is used.
	ClockSource ClockSource

	// Resampler backend to use.
	ResamplerBackend ResamplerBackend

	// Resampler profile to use.
	// If non-zero, the receiver employs resampler for two purposes:
	//  - adjust the sender clock to the receiver clock, which may differ a bit
	//  - convert the packet sample rate to the frame sample rate if they are different
	ResamplerProfile ResamplerProfile

	// Target latency, in nanoseconds.
	// The session will not start playing until it accumulates the requested latency.
	// Then, if resampler is enabled, the session will adjust its clock to keep actual
	// latency as close as possible to the target latency.
	// If zero, default value is used. Should not be negative, otherwise an error is returned.
	TargetLatency time.Duration

	// Maximum delta between current and target latency, in nanoseconds.
	// If current latency becomes larger than the target latency plus this value, the
	// session is terminated.
	// If zero, default value is used. Should not be negative, otherwise an error is returned.
	MaxLatencyOverrun time.Duration

	// Maximum delta between target and current latency, in nanoseconds.
	// If current latency becomes smaller than the target latency minus this value, the
	// session is terminated.
	// May be larger than the target latency because current latency may be negative,
	// which means that the playback run ahead of the last packet received from network.
	// If zero, default value is used.  Should not be negative, otherwise an error is returned.
	MaxLatencyUnderrun time.Duration

	// Timeout for the lack of playback, in nanoseconds.
	// If there is no playback during this period, the session is terminated.
	// This mechanism allows to detect dead, hanging, or broken clients
	// generating invalid packets.
	// If zero, default value is used. If negative, the timeout is disabled.
	NoPlaybackTimeout time.Duration

	// Timeout for broken playback, in nanoseconds.
	// If there the playback is considered broken during this period, the session
	// is terminated. The playback is broken if there is a breakage detected at every
	// BreakageDetectionWindow during BrokenPlaybackTimeout.
	// This mechanism allows to detect vicious circles like when all client packets
	// are a bit late and receiver constantly drops them producing unpleasant noise.
	// If zero, default value is used. If negative, the timeout is disabled.
	BrokenPlaybackTimeout time.Duration

	// Breakage detection window, in nanoseconds.
	// If zero, default value is used. Should not be negative, otherwise an error is returned.
	// See BrokenPlaybackTimeout.
	BreakageDetectionWindow time.Duration
}
