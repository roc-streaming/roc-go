// Code generated by generate_bindings.py script from roc-streaming/bindgen
// roc-toolkit git tag: v0.4.0, commit: 62401be9

package roc

import (
	"time"
)

// Receiver configuration.
// You can zero-initialize this struct to get a default config.
// See also Receiver.
type ReceiverConfig struct {
	// The encoding used in frames returned by receiver.
	//
	// Frame encoding defines sample format, channel layout, and sample rate in
	// local frames returned by receiver to user.
	//
	// Should be set (zero value is invalid).
	FrameEncoding MediaEncoding

	// Clock source.
	//
	// Defines whether read operation is blocking or non-blocking.
	//
	// If zero, default value is used (ClockSourceDefault).
	ClockSource ClockSource

	// Latency tuner backend.
	//
	// Defines which latency is monitored and controlled by latency tuner. Defines
	// semantics of TargetLatency, MinLatency, and MaxLatency fields.
	//
	// If zero, default backend is used (LatencyTunerBackendDefault).
	LatencyTunerBackend LatencyTunerBackend

	// Latency tuner profile.
	//
	// Defines whether latency tuning is enabled and which algorithm is used.
	//
	// If zero, default profile is used (LatencyTunerProfileDefault).
	//
	// By default, latency tuning is enabled on receiver. If you disable it on
	// receiver, you usually need to enable it on sender. In that case you also
	// need to set TargetLatency to the same value on both sides.
	LatencyTunerProfile LatencyTunerProfile

	// Resampler backend.
	//
	// Affects CPU usage, quality, and clock synchronization precision (if latency
	// tuning is enabled).
	//
	// If zero, default backend is used (ResamplerBackendDefault).
	ResamplerBackend ResamplerBackend

	// Resampler profile.
	//
	// Affects CPU usage and quality.
	//
	// If zero, default profile is used (ResamplerProfileDefault).
	ResamplerProfile ResamplerProfile

	// Target latency, in nanoseconds.
	//
	// How latency is calculated depends on LatencyTunerBackend field.
	//
	// If latency tuning is enabled on receiver (if LatencyTunerProfile is not
	// LatencyTunerProfileIntact), receiver adjusts its clock to keep actual
	// latency as close as possible to the target.
	//
	// By default, latency tuning is enabled on receiver. If you disable it on
	// receiver, you likely want to enable it on sender. In this case you also need
	// to set TargetLatency to the exact same value on both sides.
	//
	// If zero, default value is used.
	TargetLatency time.Duration

	// Maximum allowed delta between current and target latency, in nanoseconds.
	//
	// How latency is calculated depends on LatencyTunerBackend field.
	//
	// If latency tuning is enabled on receiver (if LatencyTunerProfile is not
	// LatencyTunerProfileIntact), receiver monitors current latency, and if it
	// differs from TargetLatency more than by LatencyTolerance, receiver
	// terminates connection to sender (but it then restarts if sender continues
	// streaming).
	//
	// By default, latency bounding is enabled on receiver. If you disable it on
	// receiver, you likely want to enable it on sender.
	//
	// If zero, default value is used (if latency tuning is enabled on receiver).
	LatencyTolerance time.Duration

	// Timeout for the lack of playback, in nanoseconds.
	//
	// If there is no playback during this period, receiver terminates connection
	// to to sender (but it then restarts if sender continues streaming).
	//
	// This mechanism allows to detect dead, hanging, or incompatible clients that
	// generate unparseable packets.
	//
	// If zero, default value is used. If negative, the check is disabled.
	NoPlaybackTimeout time.Duration

	// Timeout for choppy playback, in nanoseconds.
	//
	// If there is constant stuttering during this period, receiver terminates
	// connection to sender (but it then restarts if sender continues streaming).
	//
	// This mechanism allows to detect situations when playback continues but there
	// are frequent glitches, for example because there is a high ratio of late
	// packets.
	//
	// If zero, default value is used. If negative, the check is disabled.
	ChoppyPlaybackTimeout time.Duration
}
