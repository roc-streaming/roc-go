// Code generated by generate_bindings.py script from roc-streaming/bindgen
// roc-toolkit git tag: v0.4.0, commit: 62401be9

package roc

import (
	"time"
)

// Sender configuration.
// You can zero-initialize this struct to get a default config.
// See also Sender.
type SenderConfig struct {
	// The encoding used in frames passed to sender.
	//
	// Frame encoding defines sample format, channel layout, and sample rate in
	// local frames created by user and passed to sender.
	//
	// Should be set explicitly (zero value is invalid).
	FrameEncoding MediaEncoding

	// The encoding used for packets produced by sender.
	//
	// Packet encoding defines sample format, channel layout, and sample rate in
	// network packets. If packet encoding differs from frame encoding, conversion
	// is performed automatically.
	//
	// If zero, sender selects packet encoding automatically based on
	// FrameEncoding. This automatic selection matches only encodings that have
	// exact same sample rate and channel layout, and hence don't require
	// conversions. If you need conversions, you should set packet encoding
	// explicitly.
	//
	// If you want to force specific packet encoding, and built-in set of encodings
	// is not enough, you can use ContextRegisterEncoding() to register custom
	// encoding, and set PacketEncoding to registered identifier. If you use
	// signaling protocol like RTSP, it's enough to register in just on sender;
	// otherwise, you need to do the same on receiver as well.
	PacketEncoding PacketEncoding

	// The length of the packets produced by sender, in nanoseconds.
	//
	// Number of nanoseconds encoded per packet. The samples written to the sender
	// are buffered until the full packet is accumulated or the sender is flushed
	// or closed. Larger number reduces packet overhead but also does not allow
	// smaller latency.
	//
	// If zero, default value is used.
	PacketLength time.Duration

	// Enable packet interleaving.
	//
	// If non-zero, the sender shuffles packets before sending them. This may
	// increase robustness but also increases latency.
	PacketInterleaving bool

	// FEC encoding to use.
	//
	// If FEC is enabled, the sender employs a FEC encoding to generate redundant
	// packet which may be used on receiver to restore lost packets. This requires
	// both sender and receiver to use two separate source and repair endpoints.
	//
	// If zero, default encoding is used (FecEncodingDefault).
	FecEncoding FecEncoding

	// Number of source packets per FEC block.
	//
	// Used if some FEC encoding is selected.
	//
	// Sender divides stream into blocks of N source (media) packets, and adds M
	// repair (redundancy) packets to each block, where N is FecBlockSourcePackets
	// and M is FecBlockRepairPackets.
	//
	// Larger number of source packets in block increases robustness (repair
	// ratio), but also increases latency.
	//
	// If zero, default value is used.
	FecBlockSourcePackets uint32

	// Number of repair packets per FEC block.
	//
	// Used if some FEC encoding is selected.
	//
	// Sender divides stream into blocks of N source (media) packets, and adds M
	// repair (redundancy) packets to each block, where N is FecBlockSourcePackets
	// and M is FecBlockRepairPackets.
	//
	// Larger number of repair packets in block increases robustness (repair
	// ratio), but also increases traffic. Number of repair packets usually should
	// be 1/2 or 2/3 of the number of source packets.
	//
	// If zero, default value is used.
	FecBlockRepairPackets uint32

	// Clock source to use.
	//
	// Defines whether write operation is blocking or non-blocking.
	//
	// If zero, default value is used (ClockSourceDefault).
	ClockSource ClockSource

	// Latency tuner backend.
	//
	// Defines which latency is monitored and controlled by latency tuner. Defines
	// semantics of TargetLatency, MinLatency, and MaxLatency fields.
	//
	// If zero, default backend is used (LatencyTunerBackendDefault).
	LatencyTunerBackend LatencyTunerBackend

	// Latency tuner profile.
	//
	// Defines whether latency tuning is enabled and which algorithm is used.
	//
	// If zero, default profile is used (LatencyTunerProfileDefault).
	//
	// By default, latency tuning is disabled on sender. If you enable it on
	// sender, you need to disable it on receiver. You also need to set
	// TargetLatency to the exact same value on both sides.
	LatencyTunerProfile LatencyTunerProfile

	// Resampler backend.
	//
	// Affects CPU usage, quality, and clock synchronization precision (if latency
	// tuning is enabled).
	//
	// If zero, default backend is used (ResamplerBackendDefault).
	ResamplerBackend ResamplerBackend

	// Resampler profile.
	//
	// Affects CPU usage and quality.
	//
	// If zero, default profile is used (ResamplerProfileDefault).
	ResamplerProfile ResamplerProfile

	// Target latency, in nanoseconds.
	//
	// How latency is calculated depends on LatencyTunerBackend field.
	//
	// If latency tuning is enabled on sender (if LatencyTunerProfile is not
	// LatencyTunerProfileIntact), sender adjusts its clock to keep actual latency
	// as close as possible to the target.
	//
	// By default, latency tuning is disabled on sender. If you enable it on
	// sender, you need to disable it on receiver. You also need to set
	// TargetLatency to the exact same value on both sides.
	//
	// If latency tuning is enabled, TargetLatency should be non-zero.
	TargetLatency time.Duration

	// Maximum allowed delta between current and target latency, in nanoseconds.
	//
	// How latency is calculated depends on LatencyTunerBackend field.
	//
	// If latency tuning is enabled on sender (if LatencyTunerProfile is not
	// LatencyTunerProfileIntact), sender monitors current latency, and if it
	// differs from TargetLatency more than by LatencyTolerance, sender restarts
	// connection to receiver.
	//
	// By default, latency bounding is disabled on sender. If you enable it on
	// sender, you likely want to disable it on receiver.
	//
	// If zero, default value is used (if latency tuning is enabled on sender).
	LatencyTolerance time.Duration
}
